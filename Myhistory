java笔记：
1）存储位置：
   寄存器-最快的存储位置，不受控，根据需求进行分配；
   堆栈（RAM区）-通过堆栈指针上下移动分配和释放内存，Java对象不会存于该区域；
   堆(RAM区)-存储Java所有对象，new即可分配内存，可见如大量new会导致存储管理问题；
   常量存储-存在于代码中，不可变数据，某些系统存放于ROM（只读寄存器）中
   非RAM存储-类似流对象或持久化数据，存于硬盘或其他存储媒介之上，在需要时可以恢复为常规的基于RAM的对象。
2）基本类型和包装类型
   基本类型如下定义 string a = "abcde" 和 string a = new String("abcde")都是对基本类型的定义，差别在于存储方式不同
   第一种定义存储在堆栈中，第二种存在于堆中。
   static修饰的变量或方法，不会与包含它的类所关联在一起，即及时不创建依然可以调用其static方法或static域，即使多次创建对应类，其static域仍是相同内存。
   static域有且只有一份存储空间，非static则是每个对象包含一个存储空间。
3）运算符
   对象间做“=”，是左值指向右值对象，左值所指的原对象被覆盖，垃圾回收站进行清理操作，需要注意违反了面向对象设计原则，会导致域混乱（别名问题）
   包装类定义为new 对象赋值，虽然类型和所赋值相同，但指向的对象却不相同，当进行“==”或“！=”时，需要注意；对象比较时使用equals()，而且是比较的对象引用；
   短路-a && b ，只有a通过后才会继续执行，否则返回
4）直接常量（0x0f类似的表示）
5）方法重载：
   使用相同命名的方法，一般此类方法都具有独一无二的参数列表，包括参数顺序不同（但少用，不好辨别，难以维护代码）
   使用返回值区分会存在编译器可以准确识别语义，但调用者可能只关心调用的方法，却忽视返回值，此方法不一定可行
6）垃圾回收（只与内存有关，即jvm如未面临内存耗尽的情况是不会花时间进行GC）
   java垃圾回收器只能处理new分配的存储，其他方式获取的它并不知道该如何处理。
   finalize()方法可以进行一些相关终结处理，并且在下次垃圾回收时真正进行处理，但一定是垃圾回收发生时执行，也就是说，不一定会执行到。。。
   finalize()非通用清理方法，一般常见于处理本地方法（native）时进行收尾，防止C/C++未进行free()操作造成的内存泄漏。
   JVM GC方式：堆指针移动，并同时整理堆存储的对象，使其紧凑排列，减少松散存储浪费资源
   1.停止-复制---先暂停程序，遍历对象，将存活对象拷贝到另一个堆存储中，当前堆存储中的对象为非存活，即可被销毁，但这样比较消耗存储，因为需要两个堆存储
   2.标记-清扫---当程序运行稳定后，产生的垃圾较少，不适用1种清理，太耗空间，当前这种处理遍历所有引用，标记存活对象，但不进行其他处理，当遍历后清理未标记的对象，清理后的额堆存储为非连续的，如要让其连续，仍需要进程拷贝

